<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="SessionStateDown" xml:space="preserve">
    <value>GO
DROP PROCEDURE [dbo].[DeleteExpiredSessions]
GO
DROP PROCEDURE [dbo].[GetHashCode]
GO
DROP PROCEDURE [dbo].[GetMajorVersion]
GO
DROP PROCEDURE [dbo].[TempGetAppID]
GO
DROP PROCEDURE [dbo].[TempGetStateItem]
GO
DROP PROCEDURE [dbo].[TempGetStateItem2]
GO
DROP PROCEDURE [dbo].[TempGetStateItem3]
GO
DROP PROCEDURE [dbo].[TempGetStateItemExclusive]
GO
DROP PROCEDURE [dbo].[TempGetStateItemExclusive2]
GO
DROP PROCEDURE [dbo].[TempGetStateItemExclusive3]
GO
DROP PROCEDURE [dbo].[TempGetVersion]
GO
DROP PROCEDURE [dbo].[TempInsertStateItemLong]
GO
DROP PROCEDURE [dbo].[TempInsertStateItemShort]
GO
DROP PROCEDURE [dbo].[TempInsertUninitializedItem]
GO
DROP PROCEDURE [dbo].[TempReleaseStateItemExclusive]
GO
DROP PROCEDURE [dbo].[TempRemoveStateItem]
GO
DROP PROCEDURE [dbo].[TempResetTimeout]
GO
DROP PROCEDURE [dbo].[TempUpdateStateItemLong]
GO
DROP PROCEDURE [dbo].[TempUpdateStateItemLongNullShort]
GO
DROP PROCEDURE [dbo].[TempUpdateStateItemShort]
GO
DROP PROCEDURE [dbo].[TempUpdateStateItemShortNullLong]
GO</value>
  </data>
  <data name="SessionStateUp" xml:space="preserve">
    <value>CREATE PROCEDURE dbo.GetMajorVersion
	@@ver int OUTPUT
AS
BEGIN
	DECLARE @version		nchar(100)
	DECLARE @dot			int
	DECLARE @hyphen		 int
	DECLARE @SqlToExec	 nchar(4000)

	SELECT @@ver = 7
	SELECT @version = @@Version
	SELECT @hyphen = CHARINDEX(N' - ', @version)
	IF (NOT(@hyphen IS NULL) AND @hyphen &gt; 0)
	BEGIN
		SELECT @hyphen = @hyphen + 3
		SELECT @dot	= CHARINDEX(N'.', @version, @hyphen)
		IF (NOT(@dot IS NULL) AND @dot &gt; @hyphen)
		BEGIN
			SELECT @version = SUBSTRING(@version, @hyphen, @dot - @hyphen)
			SELECT @@ver	 = CONVERT(int, @version)
		END
	END
END
GO  

CREATE PROCEDURE dbo.TempGetVersion
	@ver	 char(10) OUTPUT
AS
	SELECT @ver = '2'
	RETURN 0
GO

CREATE PROCEDURE dbo.GetHashCode
	@input varchar(280),
	@hash int OUTPUT
AS
	DECLARE @hi_16bit  int
	DECLARE @lo_16bit  int
	DECLARE @hi_t	  int
	DECLARE @lo_t	  int
	DECLARE @len		int
	DECLARE @i		 int
	DECLARE @c		 int
	DECLARE @carry	 int

	SET @hi_16bit = 0
	SET @lo_16bit = 5381
	
	SET @len = DATALENGTH(@input)
	SET @i = 1
	
	WHILE (@i &lt;= @len)
	BEGIN
		SET @c = ASCII(SUBSTRING(@input, @i, 1))

		/* Formula:						
		  hash = ((hash &lt;&lt; 5) + hash) ^ c */

		/* hash &lt;&lt; 5 */
		SET @hi_t = @hi_16bit * 32 /* high 16bits &lt;&lt; 5 */
		SET @hi_t = @hi_t &amp; 0xFFFF /* zero out overflow */
		
		SET @lo_t = @lo_16bit * 32 /* low 16bits &lt;&lt; 5 */
		
		SET @carry = @lo_16bit &amp; 0x1F0000 /* move low 16bits carryover to hi 16bits */
		SET @carry = @carry / 0x10000 /* &gt;&gt; 16 */
		SET @hi_t = @hi_t + @carry
		SET @hi_t = @hi_t &amp; 0xFFFF /* zero out overflow */

		/* + hash */
		SET @lo_16bit = @lo_16bit + @lo_t
		SET @hi_16bit = @hi_16bit + @hi_t + (@lo_16bit / 0x10000)
		/* delay clearing the overflow */

		/* ^c */
		SET @lo_16bit = @lo_16bit ^ @c

		/* Now clear the overflow bits */	
		SET @hi_16bit = @hi_16bit &amp; 0xFFFF
		SET @lo_16bit = @lo_16bit &amp; 0xFFFF

		SET @i = @i + 1
	END

	/* Do a sign extension of the hi-16bit if needed */
	IF (@hi_16bit &amp; 0x8000 &lt;&gt; 0)
		SET @hi_16bit = 0xFFFF0000 | @hi_16bit

	/* Merge hi and lo 16bit back together */
	SET @hi_16bit = @hi_16bit * 0x10000 /* &lt;&lt; 16 */
	SET @hash = @hi_16bit | @lo_16bit

	RETURN 0
GO

DECLARE @cmd nchar(4000)

SET @cmd = N'
	CREATE PROCEDURE dbo.TempGetAppID
	@appName	varchar(280),
	@appId	 int OUTPUT
	AS
	SET @appName = LOWER(@appName)
	SET @appId = NULL

	SELECT @appId = AppId
	FROM dbo.ASPStateTempApplications
	WHERE AppName = @appName

	IF @appId IS NULL BEGIN
		BEGIN TRAN		

		SELECT @appId = AppId
		FROM dbo.ASPStateTempApplications WITH (TABLOCKX)
		WHERE AppName = @appName
		
		IF @appId IS NULL
		BEGIN
			EXEC GetHashCode @appName, @appId OUTPUT
			
			INSERT dbo.ASPStateTempApplications
			VALUES
			(@appId, @appName)
			
			IF @@ERROR = 2627 
			BEGIN
				DECLARE @dupApp varchar(280)
			
				SELECT @dupApp = RTRIM(AppName)
				FROM dbo.ASPStateTempApplications 
				WHERE AppId = @appId
				
				RAISERROR(''SQL session state fatal error: hash-code collision between applications ''''%s'''' and ''''%s''''. Please rename the 1st application to resolve the problem.'', 
							18, 1, @appName, @dupApp)
			END
		END

		COMMIT
	END

	RETURN 0'
EXEC(@cmd)	
GO

CREATE PROCEDURE dbo.TempGetStateItem
	@id		 nvarchar(88),
	@itemShort varbinary(7000) OUTPUT,
	@locked	 bit OUTPUT,
	@lockDate  datetime OUTPUT,
	@lockCookie int OUTPUT
AS
	DECLARE @length AS int
	DECLARE @now AS datetime
	SET @now = GETUTCDATE()

	UPDATE dbo.ASPStateTempSessions
	SET Expires = DATEADD(n, Timeout, @now), 
		@locked = Locked,
		@lockDate = LockDateLocal,
		@lockCookie = LockCookie,
		@itemShort = CASE @locked
			WHEN 0 THEN SessionItemShort
			ELSE NULL
			END,
		@length = CASE @locked
			WHEN 0 THEN DATALENGTH(SessionItemLong)
			ELSE NULL
			END
	WHERE SessionId = @id

	IF @length IS NOT NULL BEGIN
		SELECT [SessionItemLong] FROM dbo.ASPStateTempSessions WHERE SessionId = @id
	END

	RETURN 0
	
GO

CREATE PROCEDURE dbo.TempGetStateItem2
	@id		 nvarchar(88),
	@itemShort varbinary(7000) OUTPUT,
	@locked	 bit OUTPUT,
	@lockAge	int OUTPUT,
	@lockCookie int OUTPUT
AS
	DECLARE @length AS int
	DECLARE @now AS datetime
	SET @now = GETUTCDATE()

	UPDATE dbo.ASPStateTempSessions
	SET Expires = DATEADD(n, Timeout, @now), 
		@locked = Locked,
		@lockAge = DATEDIFF(second, LockDate, @now),
		@lockCookie = LockCookie,
		@itemShort = CASE @locked
			WHEN 0 THEN SessionItemShort
			ELSE NULL
			END,
		@length = CASE @locked
			WHEN 0 THEN DATALENGTH(SessionItemLong)
			ELSE NULL
			END
	WHERE SessionId = @id

	IF @length IS NOT NULL BEGIN
		SELECT [SessionItemLong] FROM dbo.ASPStateTempSessions WHERE SessionId = @id
	END

	RETURN 0
GO
			
CREATE PROCEDURE dbo.TempGetStateItem3
	@id		 nvarchar(88),
	@itemShort varbinary(7000) OUTPUT,
	@locked	 bit OUTPUT,
	@lockAge	int OUTPUT,
	@lockCookie int OUTPUT,
	@actionFlags int OUTPUT
AS
	DECLARE @length AS int
	DECLARE @now AS datetime
	SET @now = GETUTCDATE()

	UPDATE dbo.ASPStateTempSessions
	SET Expires = DATEADD(n, Timeout, @now), 
		@locked = Locked,
		@lockAge = DATEDIFF(second, LockDate, @now),
		@lockCookie = LockCookie,
		@itemShort = CASE @locked
			WHEN 0 THEN SessionItemShort
			ELSE NULL
			END,
		@length = CASE @locked
			WHEN 0 THEN DATALENGTH(SessionItemLong)
			ELSE NULL
			END,
		/* If the Uninitialized flag (0x1) if it is set,
		  remove it and return InitializeItem (0x1) in actionFlags */
		Flags = CASE
			WHEN (Flags &amp; 1) &lt;&gt; 0 THEN (Flags &amp; ~1)
			ELSE Flags
			END,
		@actionFlags = CASE
			WHEN (Flags &amp; 1) &lt;&gt; 0 THEN 1
			ELSE 0
			END
	WHERE SessionId = @id

	IF @length IS NOT NULL BEGIN
		SELECT [SessionItemLong] FROM dbo.ASPStateTempSessions WHERE SessionId = @id
	END

	RETURN 0
GO

CREATE PROCEDURE dbo.TempGetStateItemExclusive
	@id		 nvarchar(88),
	@itemShort varbinary(7000) OUTPUT,
	@locked	 bit OUTPUT,
	@lockDate  datetime OUTPUT,
	@lockCookie int OUTPUT
AS
	DECLARE @length AS int
	DECLARE @now AS datetime
	DECLARE @nowLocal AS datetime

	SET @now = GETUTCDATE()
	SET @nowLocal = GETDATE()
	
	UPDATE dbo.ASPStateTempSessions
	SET Expires = DATEADD(n, Timeout, @now), 
		LockDate = CASE Locked
			WHEN 0 THEN @now
			ELSE LockDate
			END,
		@lockDate = LockDateLocal = CASE Locked
			WHEN 0 THEN @nowLocal
			ELSE LockDateLocal
			END,
		@lockCookie = LockCookie = CASE Locked
			WHEN 0 THEN LockCookie + 1
			ELSE LockCookie
			END,
		@itemShort = CASE Locked
			WHEN 0 THEN SessionItemShort
			ELSE NULL
			END,
		@length = CASE Locked
			WHEN 0 THEN DATALENGTH(SessionItemLong)
			ELSE NULL
			END,
		@locked = Locked,
		Locked = 1
	WHERE SessionId = @id

	IF @length IS NOT NULL BEGIN
		SELECT [SessionItemLong] FROM dbo.ASPStateTempSessions WHERE SessionId = @id
	END

	RETURN 0
GO

CREATE PROCEDURE dbo.TempGetStateItemExclusive2
	@id		 nvarchar(88),
	@itemShort varbinary(7000) OUTPUT,
	@locked	 bit OUTPUT,
	@lockAge	int OUTPUT,
	@lockCookie int OUTPUT
AS
	DECLARE @length AS int
	DECLARE @now AS datetime
	DECLARE @nowLocal AS datetime

	SET @now = GETUTCDATE()
	SET @nowLocal = GETDATE()
	
	UPDATE dbo.ASPStateTempSessions
	SET Expires = DATEADD(n, Timeout, @now), 
		LockDate = CASE Locked
			WHEN 0 THEN @now
			ELSE LockDate
			END,
		LockDateLocal = CASE Locked
			WHEN 0 THEN @nowLocal
			ELSE LockDateLocal
			END,
		@lockAge = CASE Locked
			WHEN 0 THEN 0
			ELSE DATEDIFF(second, LockDate, @now)
			END,
		@lockCookie = LockCookie = CASE Locked
			WHEN 0 THEN LockCookie + 1
			ELSE LockCookie
			END,
		@itemShort = CASE Locked
			WHEN 0 THEN SessionItemShort
			ELSE NULL
			END,
		@length = CASE Locked
			WHEN 0 THEN DATALENGTH(SessionItemLong)
			ELSE NULL
			END,
		@locked = Locked,
		Locked = 1
	WHERE SessionId = @id

	IF @length IS NOT NULL BEGIN
		SELECT [SessionItemLong] FROM dbo.ASPStateTempSessions WHERE SessionId = @id
	END

	RETURN 0
GO

CREATE PROCEDURE dbo.TempGetStateItemExclusive3
	@id		 nvarchar(88),
	@itemShort varbinary(7000) OUTPUT,
	@locked	 bit OUTPUT,
	@lockAge	int OUTPUT,
	@lockCookie int OUTPUT,
	@actionFlags int OUTPUT
AS
	DECLARE @length AS int
	DECLARE @now AS datetime
	DECLARE @nowLocal AS datetime

	SET @now = GETUTCDATE()
	SET @nowLocal = GETDATE()
	
	UPDATE dbo.ASPStateTempSessions
	SET Expires = DATEADD(n, Timeout, @now), 
		LockDate = CASE Locked
			WHEN 0 THEN @now
			ELSE LockDate
			END,
		LockDateLocal = CASE Locked
			WHEN 0 THEN @nowLocal
			ELSE LockDateLocal
			END,
		@lockAge = CASE Locked
			WHEN 0 THEN 0
			ELSE DATEDIFF(second, LockDate, @now)
			END,
		@lockCookie = LockCookie = CASE Locked
			WHEN 0 THEN LockCookie + 1
			ELSE LockCookie
			END,
		@itemShort = CASE Locked
			WHEN 0 THEN SessionItemShort
			ELSE NULL
			END,
		@length = CASE Locked
			WHEN 0 THEN DATALENGTH(SessionItemLong)
			ELSE NULL
			END,
		@locked = Locked,
		Locked = 1,

		/* If the Uninitialized flag (0x1) if it is set,
		  remove it and return InitializeItem (0x1) in actionFlags */
		Flags = CASE
			WHEN (Flags &amp; 1) &lt;&gt; 0 THEN (Flags &amp; ~1)
			ELSE Flags
			END,
		@actionFlags = CASE
			WHEN (Flags &amp; 1) &lt;&gt; 0 THEN 1
			ELSE 0
			END
	WHERE SessionId = @id

	IF @length IS NOT NULL BEGIN
		SELECT SessionItemLong FROM dbo.ASPStateTempSessions WHERE SessionId = @id
	END

	RETURN 0
GO

CREATE PROCEDURE dbo.TempReleaseStateItemExclusive
	@id		 nvarchar(88),
	@lockCookie int
AS
	UPDATE dbo.ASPStateTempSessions
	SET Expires = DATEADD(n, Timeout, GETUTCDATE()), 
		Locked = 0
	WHERE SessionId = @id AND LockCookie = @lockCookie

	RETURN 0
GO

CREATE PROCEDURE dbo.TempInsertUninitializedItem
	@id		 nvarchar(88),
	@itemShort varbinary(7000),
	@timeout	int
AS	

	DECLARE @now AS datetime
	DECLARE @nowLocal AS datetime
	
	SET @now = GETUTCDATE()
	SET @nowLocal = GETDATE()

	INSERT dbo.ASPStateTempSessions 
		(SessionId, 
		 SessionItemShort, 
		 Timeout, 
		 Expires, 
		 Locked, 
		 LockDate,
		 LockDateLocal,
		 LockCookie,
		 Flags,
		 Created) 
	VALUES 
		(@id, 
		 @itemShort, 
		 @timeout, 
		 DATEADD(n, @timeout, @now), 
		 0, 
		 @now,
		 @nowLocal,
		 1,
		 1,
		 @now)

	RETURN 0
GO

CREATE PROCEDURE dbo.TempInsertStateItemShort
	@id		 nvarchar(88),
	@itemShort varbinary(7000),
	@timeout	int
AS	

	DECLARE @now AS datetime
	DECLARE @nowLocal AS datetime
	
	SET @now = GETUTCDATE()
	SET @nowLocal = GETDATE()

	INSERT dbo.ASPStateTempSessions 
		(SessionId, 
		 SessionItemShort, 
		 Timeout, 
		 Expires, 
		 Locked, 
		 LockDate,
		 LockDateLocal,
		 LockCookie,
		 Flags,
		 Created) 
	VALUES 
		(@id, 
		 @itemShort, 
		 @timeout, 
		 DATEADD(n, @timeout, @now), 
		 0, 
		 @now,
		 @nowLocal,
		 1,
		 0,
		 @now)

	RETURN 0
GO

CREATE PROCEDURE dbo.TempInsertStateItemLong
	@id		 nvarchar(88),
	@itemLong  image,
	@timeout	int
AS	
	DECLARE @now AS datetime
	DECLARE @nowLocal AS datetime
	
	SET @now = GETUTCDATE()
	SET @nowLocal = GETDATE()

	INSERT dbo.ASPStateTempSessions 
		(SessionId, 
		 SessionItemLong, 
		 Timeout, 
		 Expires, 
		 Locked, 
		 LockDate,
		 LockDateLocal,
		 LockCookie,
		 Flags,
		 Created) 
	VALUES 
		(@id, 
		 @itemLong, 
		 @timeout, 
		 DATEADD(n, @timeout, @now), 
		 0, 
		 @now,
		 @nowLocal,
		 1,
		 0,
		 @now)

	RETURN 0
GO

CREATE PROCEDURE dbo.TempUpdateStateItemShort
	@id		 nvarchar(88),
	@itemShort varbinary(7000),
	@timeout	int,
	@lockCookie int
AS	
	UPDATE dbo.ASPStateTempSessions
	SET Expires = DATEADD(n, @timeout, GETUTCDATE()), 
		SessionItemShort = @itemShort, 
		Timeout = @timeout,
		Locked = 0
	WHERE SessionId = @id AND LockCookie = @lockCookie

	RETURN 0
GO

CREATE PROCEDURE dbo.TempUpdateStateItemShortNullLong
	@id		 nvarchar(88),
	@itemShort varbinary(7000),
	@timeout	int,
	@lockCookie int
AS	
	UPDATE dbo.ASPStateTempSessions
	SET Expires = DATEADD(n, @timeout, GETUTCDATE()), 
		SessionItemShort = @itemShort, 
		SessionItemLong = NULL, 
		Timeout = @timeout,
		Locked = 0
	WHERE SessionId = @id AND LockCookie = @lockCookie

	RETURN 0
GO

CREATE PROCEDURE dbo.TempUpdateStateItemLong
	@id		 nvarchar(88),
	@itemLong  image,
	@timeout	int,
	@lockCookie int
AS	
	UPDATE dbo.ASPStateTempSessions
	SET Expires = DATEADD(n, @timeout, GETUTCDATE()), 
		SessionItemLong = @itemLong,
		Timeout = @timeout,
		Locked = 0
	WHERE SessionId = @id AND LockCookie = @lockCookie

	RETURN 0
GO

CREATE PROCEDURE dbo.TempUpdateStateItemLongNullShort
	@id		 nvarchar(88),
	@itemLong  image,
	@timeout	int,
	@lockCookie int
AS	
	UPDATE dbo.ASPStateTempSessions
	SET Expires = DATEADD(n, @timeout, GETUTCDATE()), 
		SessionItemLong = @itemLong, 
		SessionItemShort = NULL,
		Timeout = @timeout,
		Locked = 0
	WHERE SessionId = @id AND LockCookie = @lockCookie

	RETURN 0
GO

CREATE PROCEDURE dbo.TempRemoveStateItem
	@id	 nvarchar(88),
	@lockCookie int
AS
	DELETE dbo.ASPStateTempSessions
	WHERE SessionId = @id AND LockCookie = @lockCookie
	RETURN 0
GO

CREATE PROCEDURE dbo.TempResetTimeout
	@id	 nvarchar(88)
AS
	UPDATE dbo.ASPStateTempSessions
	SET Expires = DATEADD(n, Timeout, GETUTCDATE())
	WHERE SessionId = @id
	RETURN 0
GO

CREATE PROCEDURE dbo.DeleteExpiredSessions
AS
	DECLARE @now datetime
	SET @now = GETUTCDATE()

	DELETE dbo.ASPStateTempSessions
	WHERE Expires &lt; @now

	RETURN 0
GO</value>
  </data>
</root>